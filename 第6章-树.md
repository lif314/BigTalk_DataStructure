# 第六章 树
*树(tree)：是n个结点的有限集。n=0时称为空树。在任意一棵非空树中：(1)有且仅有一个特定的称为根(root)的结点；(2)n>1时，其余结点可分为m(m>0)个互不相交的有限集T1,T2,……Tm,其中每一个集合本身又是一棵树，并且称为根的子树(Subtree)。

*注意两点：n>0时根结点是唯一的；m>0时，子树的个数没有限制，但它们一定是互不相交的。

*结点分类：树的结点包含一个数据元素和若干指向其子树的分支。结点拥有的子树数称为结点的度(Degree)。度为0的结点称为叶结点（Leaf）或终端结点；度不为0的结点称为非终端结点或分支结点。除根节点之外，分支结点也称为内部结点。树的度就是各结点的度的最大值。

*结点之间的关系：结点的子树的根称为该结点的孩子(Child)，相应地，该结点称为孩子的双亲(Parent)；同一个双亲的孩子之间互称兄弟(Sibling)。结点的祖先是从根到该结点所经分支上所有的结点。以某结点为根的子树中任一结点都成为该结点的子孙。

*结点的层次(Level)从根开始定义起，根为第一层，根的孩子为第二层。双亲在同一层的结点互为堂兄弟。树的结点的最大层次称为树的深度Depth或高度。

*如果将树中结点的各子树看成从左到右是有次序的，不能交换的，则称该树为有序树，否则称为无序树。

*森林(Forest)是m(m>=0)棵互不相交的树的集合。

*线性结构：第一个元素无前驱；最后一个元素无后继；中间元素一个前驱一个后继

树结构：根结点无双亲，唯一；叶结点无孩子，可以多个；中间结点一个双亲多个孩子

## 树的抽象数据类型

	ADT 树(tree)
	Data 
		树是由一个根结点和若干棵子树构成的。树中结点具有相同的数据类型及层次关系。
	Operation
		InitTree(*T) :构造空树T
		DestroyTree(*T): 销毁树
		CreateTree(*T, definition):按definition中给出树的定义来构造树
		ClearTree(*T): 清空树
		TreeEmpty(*T): 空树返回true
		TreeDepth(*T): 返回T的深度
		Root(*T): 返回T的根结点
		Value(T, cur_e): cur_e是树T中的一个结点，返回此结点的值
		Assign(T, cur-e, value): 给树T的结点cur_e赋值为value
		Parent(T, cur_e): 若cur_e不是根结点，则返回它的双亲
		LeftChild(T, cur_e): 若cur_e是树T的非叶结点，则返回它的最左孩子，否则返回空。
		RightSibling(T, cur_e): 若cur_e有右兄弟，则返回右兄弟，否则返回空。
		InsertChild(*T, *p, i , c):其中p指向树T的某个结点，i为所指结点p的度加上1，若非空树c与T不相交，操作结果为插入c为树T中p指向结点的第i棵子树。
		DeleteChild(*T, *p, i): 其中p为指向树T的某个结点，i为所指结点p的度，操作结果为删除T中P所指向结点的第i棵子树。
	endADT

## 树的存储结构

#### 双亲表示法
*设计思路：假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指向双亲结点在数组中的位置。data是数据域，parent是指针域，存储该结点的双亲在数组中的下标（根结点为-1）。

*结构代码：

	/*树的双亲表示法结点结构定义*/
	#define MAX_TREE_SIZE 100
	typedef int TElemType; /*数结构的数据类型，目前为整型*/
	typedef struct PTNode{  /*结点结构*/
		TElemType data; /*结点数据*/
		int parent; 	/*双亲位置*/
	} PTNode; 

	typedef struct{ /*树结构*/
		PTNode nodes[MAX_TREE_SIZE];/*结点数组*/
		int r, n; /*根的位置和结点数*/
	} PTree;

*找双亲O(1),找结点的孩子，遍历整个结构

*改进：如果要寻找结点的孩子，则增加一个结点最左边孩子的域，长子域(firstChild)，没有孩子，则置-1；如果关注兄弟关系，则增加右兄弟域(Rightsib)，记录右兄弟的下标……

##### 存储结构设计是一个非常灵活的过程。一个存储结构设计得是否合理，取决于基于该存储结构的运算是否适合、是否方便，时间复杂度好不好等。

#### 孩子表示法
##### 尝试思路
多重链表表示法——使用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点。但每个结点的度不相同，怎么解决？

*方案一：指针域的个数等于树的度（各结点度的最大值），可能浪费空间

data child1 child2 ...

*方案二：每个结点的指针域的个数等于该结点的度。专门取一个位置来存储结点指针域的个数（度域）。各结点是不同的结构，加上要维护结点的度的数值，在运算上会带来时间的损耗。

data degree child1 child2...

##### 孩子表示法：
大致思路：结点存储在数组中，用单链表来表示关系

具体做法：把每个结点的孩子结点排列起来，以单链表结构存储，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。

孩子链表的结点：  child next

child是数据域，存储某个结点在表头数组中的下标；next是指针域，存储指向下一个孩子结点的指针   

表头数组的表头结点： data firstchild

data是数据域，存储某结点的数据信息；firstchild是指针域，存储该结点的孩子链表的头指针。

*代码实现

	/*树的孩子表示法结构定义*/
	#define MAX_TREE_SIZE 100
	typedef struct CTNode{ /*孩子结点*/
		int child;  /*存放某结点在表头数组中的下标*/
		struct CTNode * next;/*下一孩子的指针*/
	} *ChildPtr;

	typedef struct{ /*表头结构*/
		TElemType data;
		ChildPtr firstchild;
	} CTBox;

	typedef struct{ /*树结构*/
		CTBox nodes[MAX_TREE_SIZE];/*结点数组*/
		int r, n; /*根的位置和结点数*/
	} CTree;

*分析：遍历方便，可查找孩子、兄弟，但很难找到双亲

*双亲孩子表示法

data parent（双亲域，存放双亲在数组中的下标） firstchild 

child next
		

#### 孩子兄弟表示法
*思路：任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是惟一的。因此，我们可以设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。

data firstchild rightsib

数据域 指针域，存储该结点的第一个孩子的存储地址 指针域，存储该结点的右兄弟的存储地址

*结构代码

	/*树的孩子兄弟表示法结构定义*/
	typedef struct CSNode{
		TElemType data;
		struct CSNode *firstchild, *rightsib;
	} CSNode, *CSTree;

*如果需要查找双亲，可以增加parent指针

*该方法最大的好处是将一棵复杂的树变成了一棵二叉树

 
## 二叉树

### 基本概念
二分折半查找

二叉树(Binary Tree): 是n个结点的有限集合，该集合或者为空集，或者是由一个根结点和两课互不相交的、分别称为根结点的左子树和右子树的二叉树组成的。

特点：1、每个结点最多有两个子树；2、左子树与右子树有顺序，次序不能随意颠倒；3、即使某结点只有一颗树，也要区分左右。

*特殊二叉树

斜树：所有结点只有左子树或者右子树。

满二叉树：所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上。

完全二叉树：对一棵具有n个结点的二叉树按层序编号，如果编号为i的结点与同样深度的满二叉树中编号为i的结点在二叉树中的位置完全相同。（即：只允许右侧叶子结点为空）

### 二叉树的性质
1、在二叉树中的第i层上至多有2^(i-1)个结点。

2、深度为k的二叉树至多有2^k-1个结点。

3、对任何一棵二叉树T，如果其终端结点数为n0,度为2的结点数为n2，则n0 = n2 + 1。   

结点总数：n = n0 + n1 + n2;   总支线数= n- 1 = n1 + n2 = n0 + n1 + n2 -1

4、具有n个结点的完全二叉树的深度为[log(2n)] + 1向下取整

5、如果对一棵有n个结点的完全二叉树（其深度为[log(2n)] + 1)的结点按层序编号有：

（1）如果i=1，则i是二叉树的根，无双亲；如果i>1，则双亲为[i /2]向下取整

（2）如果2i>n,则结点i无左孩子，否则其左孩子是结点2i

（3）如果2i+1>n,则结点i无右孩子，否则其右孩子为2i+1

### 二叉树的存储结构
*顺序存储结构：用一维数组存储二叉树的结点，并且结点的存储位置，也就是舒徐的下标体现结点之间的逻辑关系。（按层序编号即可）

*二叉链表： lchild data rchild 

结构定义代码：
	/* 二叉树的二叉链表结点结构定义*/
	typedef struct BitNode{
		TElemType data; /*数据域*/
		struct BitNode * lchild, rchild; /*左右孩子指针*/
	} BitNode, *BitTree;


### 遍历二叉树
*遍历原理(traversing binary tree)：从根结点出发，按照某种次序依次访问二叉树中所有的结点，使得每个结点被访问一次且仅被访问一次。

*遍历方法：

*遍历的实质：将树中的结点变成不同的线性序列。

1、前序遍历：规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，在前序遍历右子树。根结点——>左孩子——>右孩子

*递归实现前序遍历算法
	
	/*void PreOrderTraverse(BiTree T){
		if(T ==  NULL)
			return;
		printf("%c", T->data);/*显示结点数据*/
		PreOrderTraverse(T->lchild); /*先遍历左子树*/
		PreOrderTraverse(T->rchild); /*最后遍历右子树*/
	}

2、中序遍历：规则是若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后访问根结点，最后中序遍历右子树。左子树——>根结点——>右子树。

*递归实现中序遍历算法

	/*二叉树中序遍历递归算法*/
	void InOrderTraverse(BiTree T){
		if (T == NULL)
			return;
		InOrderTraverse(T->lchild;) /*中序遍历左子树*/
		printf("%c", T->data);
		InOrderTraverse(T->rchild); /*最后中序遍历右子树*/
	}
		
3、后序遍历：规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后访问根结点。左子树——>右子树——>根结点。

*递归实现后序遍历算法

	/*二叉树后序遍历递归算法*/
	PostOrderTraverse(BiTree T){
		if(T == NULL)
			return;
		PostOrderTraverse(T->lchild);/*先后序遍历左子树*/
		PostOrderTraverse(T->rchild); /*再后序遍历右子树*/
		printf("%c", T->data);  /*显示结点数据*/
	}

4、层序遍历（队列）：规则是若树为空，则空操作返回，否则将从树的第一层，也就是根结点开始访问，从上向下逐层遍历，在同一层中，按从左到右的顺序对结点逐一访问。

**考题：推导遍历结果

知道一棵二叉树的前序遍历结果是ABCDEF，中序遍历序列是CBAEDF，求后序？CBEFDA

##### 二叉树遍历的性质
1、已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。

2、已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。

3、已知前序遍历序列和后序遍历序列，不能确定一棵二叉树。

### 二叉树的建立
算法思路：扩展二叉树，使每个存有数据的结点都有左右孩子，虚结点中存储特殊字符，如“#”，然后求出二叉树的前序（中序或者后序）遍历序列，按遍历顺序（递归方法）将其依次输入即可。

	/*按前序输入二叉树的值（一个字符）*/
	/*# 表示空树，构造二叉链表表示二叉树T*/
	viod CreateBiTree(BiTree *T){
		TElemType ch;
		scanf("%c", &ch);
		if(ch == '#')
			*T = NULL;
		else{
			*T = (BiTree)malloc(sizeof(BiNode));
			if(! *T)
				exit(OVERFLOW);
				(*T)->data = ch;   /*生成根结点*/
				CreateBiTree(&(*T)->lchild); /*构造左子树*/
				CreateBiTree(&(*T)->rchild); /*构造右子树*/
		}
	}
		

技巧：如果输入字符顺序为前序序列，则递归生成也是前序序列，注意递归函数的顺序。


### 线索二叉树
定义：把指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded Binary Tree)。

建立目的：充分利用那些空地址，使其存放指向结点在某种遍历次序下的前驱和后继的地址。
 
线索化：对二叉树以某种次序遍历使其变为线索二叉树的过程。通俗地讲，就是将二叉树转化为双向链表。

注意：为明确lchild(rchild)存放是孩子还是前驱，需要设置两个标志域，ltag和rtag，通常为0或1

结点结构：lchild ltag data rtag rchild  （tag为0表示孩子，为1表示前驱或后继）


#### 线索二叉树结构实现
*结构定义代码：

	/*二叉树的二叉线索存储结构定义*/
	typedef enum { Link, Thread} PointerTag; /*Link==0表示指向左右孩子*/
											 /*Thread==1表示指向前驱或者后继的线索*/	typedef struct BiThrNode{ /*结点结构*/
		TElemType data;      /*结点数据*/
		struct BiThrNode *lchild, *rchild;/*左右孩子指针*/
		PointerTag LTag，RTag;   /*左右标志*/
	} BiThrNode, *BiThrNode;

线索化的实质就是将二叉表中的空指针改为指向前驱或者后继的线索。由于前驱和后继的信息只有在遍历该二叉树的过程中才能得到，所以线索化的过程就是在遍历的过程中修改空指针的过程。

*中序遍历线索化

	BiThrNode pre; /*全局变量，始终指向刚刚访问过的结点*/
	/*中序遍历进行中序线索化*/
	void InThreading(BiThrTree p){
		if(p){
			InThreading(p->lchild);  /*递归左子树线索化*/

			if(!p->lchild){   /*没有左孩子*/
				p->LTag = Thread;   /*前驱线索*/
				p->lchild = pre;   /*左孩子指向前驱*/
			}
			if(!pre->rchild){   /*前驱没有右孩子*/
				pre->RTag = Thread;  /*后继线索*/
				pre->rchild = p;   /*前驱的右孩子指向后继（当前结点p）*/
			}
			pre = p;  /*保持pre指向p的前驱*/

			InThreading(p->rchild);  /*递归右子树线索化*/
		}
	}

解析：整体框架——中序遍历递归的顺序

线索化解构：如果某结点的左指针域为空，因为刚访问了前驱结点，所有将pre赋给p->lchild,且修改LTag;而此时还未访问p的后继，故可用pre->rchild做判断，如果为空，则p就是pre的后继，所以有pre->rchild=p,且修改RTag。最后，pre = p,进行下一次使用。

